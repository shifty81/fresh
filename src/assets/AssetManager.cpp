#include "assets/AssetManager.h"

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>

// Include Lua headers only if available - using extern "C" to ensure C linkage
#ifdef FRESH_LUA_AVAILABLE
extern "C" {
    #include <lauxlib.h>
    #include <lua.h>
    #include <lualib.h>
}
#endif // FRESH_LUA_AVAILABLE

namespace fs = std::filesystem;

namespace fresh
{

// Constants for Lua configuration formatting
constexpr const char* LUA_NEWLINE_INDENT = "\n";
constexpr const char* LUA_TABLE_INDENT = "    ";
constexpr const char* LUA_ENTRY_INDENT = "        ";

// Initialize static instance
AssetManager* AssetManager::instance_ = nullptr;

AssetManager::AssetManager() : luaState_(nullptr), initialized_(false)
{
    // Initialize supported asset type extensions
    assetTypeExtensions_["Texture"] = {".png", ".jpg", ".jpeg", ".bmp", ".tga", ".dds"};
    assetTypeExtensions_["Model"] = {".obj", ".fbx", ".gltf", ".glb", ".dae"};
    assetTypeExtensions_["Script"] = {".lua", ".js", ".py"};
    assetTypeExtensions_["Audio"] = {".wav", ".mp3", ".ogg", ".flac"};
    assetTypeExtensions_["Shader"] = {".glsl", ".hlsl", ".vert", ".frag", ".vs", ".fs"};
    assetTypeExtensions_["Config"] = {".json", ".xml", ".yaml", ".yml", ".ini"};
}

AssetManager::~AssetManager()
{
    Shutdown();
}

AssetManager* AssetManager::GetInstance()
{
    if (!instance_) {
        instance_ = new AssetManager();
    }
    return instance_;
}

bool AssetManager::Initialize(const std::string& assetRootPath)
{
    if (initialized_) {
        std::cout << "[AssetManager] Already initialized" << std::endl;
        return true;
    }

    assetRootPath_ = assetRootPath;
    luaConfigPath_ = assetRootPath_ + "/asset_config.lua";

    // Ensure asset root directory exists
    if (!EnsureDirectoryExists(assetRootPath_)) {
        std::cerr << "[AssetManager] Failed to create asset root directory: " << assetRootPath_
                  << std::endl;
        return false;
    }

    // Initialize Lua
    if (!InitializeLua()) {
        std::cerr << "[AssetManager] Failed to initialize Lua" << std::endl;
        return false;
    }

    // Create default asset_config.lua if it doesn't exist
    if (!fs::exists(luaConfigPath_)) {
        std::ofstream configFile(luaConfigPath_);
        if (configFile.is_open()) {
            configFile << "-- Asset Configuration File\n";
            configFile << "-- Auto-generated by Fresh Voxel Engine Asset Manager\n\n";
            configFile << "Assets = {\n";
            configFile << "    Textures = {},\n";
            configFile << "    Models = {},\n";
            configFile << "    Scripts = {},\n";
            configFile << "    Audio = {},\n";
            configFile << "    Shaders = {},\n";
            configFile << "    Configs = {}\n";
            configFile << "}\n\n";
            configFile << "return Assets\n";
            configFile.close();
            std::cout << "[AssetManager] Created default asset_config.lua" << std::endl;
        }
    }

    initialized_ = true;
    std::cout << "[AssetManager] Initialized with root: " << assetRootPath_ << std::endl;
    return true;
}

void AssetManager::Shutdown()
{
    if (!initialized_) {
        return;
    }

    CloseLua();
    importCallbacks_.clear();
    initialized_ = false;

    std::cout << "[AssetManager] Shutdown complete" << std::endl;
}

bool AssetManager::ProcessNewAsset(const std::string& sourcePath, const std::string& assetType)
{
    if (!initialized_) {
        std::cerr << "[AssetManager] Not initialized" << std::endl;
        return false;
    }

    std::cout << "[AssetManager] Processing new asset: " << sourcePath << " (Type: " << assetType
              << ")" << std::endl;

    // Validate the asset
    if (!ValidateAsset(sourcePath, assetType)) {
        std::cerr << "[AssetManager] Asset validation failed" << std::endl;
        return false;
    }

    // Get destination folder
    std::string destFolder = assetRootPath_ + "/" + GetAssetTypeFolder(assetType);

    // Ensure destination directory exists
    if (!EnsureDirectoryExists(destFolder)) {
        std::cerr << "[AssetManager] Failed to create destination directory: " << destFolder
                  << std::endl;
        return false;
    }

    // Copy file to destination
    fs::path srcPath = sourcePath;
    fs::path destPath = fs::path(destFolder) / srcPath.filename();

    try {
        // Copy the file
        fs::copy(srcPath, destPath, fs::copy_options::overwrite_existing);
        std::cout << "[AssetManager] Copied asset to: " << destPath.string() << std::endl;

        // Extract asset name (filename without extension)
        std::string assetName = srcPath.stem().string();

        // Get relative path from asset root
        std::string relativePath = fs::relative(destPath, assetRootPath_).string();

        // Replace backslashes with forward slashes for cross-platform compatibility
        std::replace(relativePath.begin(), relativePath.end(), '\\', '/');

        // Update Lua configuration
        if (!UpdateLuaConfiguration(relativePath, assetType, assetName)) {
            std::cerr << "[AssetManager] Failed to update Lua configuration" << std::endl;
            // Continue anyway, file is copied
        }

        // Fire callbacks
        OnAssetImported(relativePath, assetType);

        std::cout << "[AssetManager] Asset import completed successfully" << std::endl;
        return true;

    } catch (const fs::filesystem_error& ex) {
        std::cerr << "[AssetManager] Filesystem error: " << ex.what() << std::endl;
        return false;
    }
}

std::string AssetManager::GetAssetTypeFolder(const std::string& assetType) const
{
    // Return folder name with 's' suffix for plural
    return assetType + "s";
}

bool AssetManager::UpdateLuaConfiguration(const std::string& assetPath,
                                          const std::string& assetType,
                                          const std::string& assetName)
{
    if (!luaState_) {
        std::cerr << "[AssetManager] Lua state not initialized" << std::endl;
        return false;
    }

    // Read the current config file
    std::ifstream configFile(luaConfigPath_);
    if (!configFile.is_open()) {
        std::cerr << "[AssetManager] Cannot open config file for reading" << std::endl;
        return false;
    }

    std::string fileContent((std::istreambuf_iterator<char>(configFile)),
                            std::istreambuf_iterator<char>());
    configFile.close();

    // Find the appropriate table section
    std::string tableName = assetType + "s";
    std::string searchPattern = tableName + " = {";
    size_t tablePos = fileContent.find(searchPattern);

    if (tablePos == std::string::npos) {
        std::cerr << "[AssetManager] Could not find table: " << tableName << std::endl;
        return false;
    }

    // Find the closing brace for this table
    size_t bracePos = fileContent.find("},", tablePos);
    if (bracePos == std::string::npos) {
        bracePos = fileContent.find("}", tablePos);
    }

    if (bracePos == std::string::npos) {
        std::cerr << "[AssetManager] Malformed table in config file" << std::endl;
        return false;
    }

    // Create new entry
    std::string newEntry =
        std::string(LUA_ENTRY_INDENT) + "{\"" + assetName + "\", \"" + assetPath + "\"},\n";

    // Check if table is empty (only whitespace between braces)
    size_t contentStart = tablePos + searchPattern.length();
    std::string tableContent = fileContent.substr(contentStart, bracePos - contentStart);
    bool isEmpty = tableContent.find_first_not_of(" \t\n\r") == std::string::npos;

    // Insert the new entry
    if (isEmpty) {
        // Insert after the opening brace with proper indentation
        fileContent.insert(contentStart,
                           std::string(LUA_NEWLINE_INDENT) + newEntry + LUA_TABLE_INDENT);
    } else {
        // Insert before the closing brace
        fileContent.insert(bracePos, newEntry);
    }

    // Write back to file
    std::ofstream outFile(luaConfigPath_);
    if (!outFile.is_open()) {
        std::cerr << "[AssetManager] Cannot open config file for writing" << std::endl;
        return false;
    }

    outFile << fileContent;
    outFile.close();

    std::cout << "[AssetManager] Updated Lua configuration: " << assetName << " -> " << assetPath
              << std::endl;

    return true;
}

bool AssetManager::LoadAssetsFromLua(const std::string& configPath)
{
#ifdef FRESH_LUA_AVAILABLE
    if (!luaState_) {
        std::cerr << "[AssetManager] Lua state not initialized" << std::endl;
        return false;
    }

    // Execute the Lua config file
    if (luaL_dofile(luaState_, configPath.c_str()) != LUA_OK) {
        std::cerr << "[AssetManager] Error loading Lua file: " << lua_tostring(luaState_, -1)
                  << std::endl;
        lua_pop(luaState_, 1);
        return false;
    }

    std::cout << "[AssetManager] Loaded assets from Lua config: " << configPath << std::endl;

    // The config is now loaded and can be accessed via Lua API
    // Example: access Assets.Textures table
    lua_getglobal(luaState_, "Assets");
    if (lua_istable(luaState_, -1)) {
        std::cout << "[AssetManager] Assets table found in Lua" << std::endl;

        // Example: iterate Textures
        lua_getfield(luaState_, -1, "Textures");
        if (lua_istable(luaState_, -1)) {
            size_t len = lua_rawlen(luaState_, -1);
            std::cout << "[AssetManager] Found " << len << " texture entries" << std::endl;
        }
        lua_pop(luaState_, 1); // pop Textures
    }
    lua_pop(luaState_, 1); // pop Assets

    return true;
#else
    // Lua not available - return success but don't actually load from Lua
    std::cout << "[AssetManager] Lua not available - skipping Lua config load: " << configPath
              << std::endl;
    return true;
#endif
}

bool AssetManager::ValidateAsset(const std::string& filePath, const std::string& assetType) const
{
    // Check if file exists
    if (!fs::exists(filePath)) {
        std::cerr << "[AssetManager] File does not exist: " << filePath << std::endl;
        return false;
    }

    // Check if it's a regular file
    if (!fs::is_regular_file(filePath)) {
        std::cerr << "[AssetManager] Not a regular file: " << filePath << std::endl;
        return false;
    }

    // Get file extension
    std::string extension = GetFileExtension(filePath);

    // Check if extension is supported for this asset type
    auto it = assetTypeExtensions_.find(assetType);
    if (it != assetTypeExtensions_.end()) {
        const auto& supportedExts = it->second;
        auto extIt = std::find(supportedExts.begin(), supportedExts.end(), extension);
        if (extIt == supportedExts.end()) {
            std::cerr << "[AssetManager] Unsupported extension " << extension << " for asset type "
                      << assetType << std::endl;
            return false;
        }
    }

    return true;
}

std::vector<std::string> AssetManager::GetSupportedAssetTypes() const
{
    std::vector<std::string> types;
    for (const auto& pair : assetTypeExtensions_) {
        types.push_back(pair.first);
    }
    return types;
}

void AssetManager::RegisterImportCallback(const std::string& callbackName,
                                          AssetImportCallback callback)
{
    importCallbacks_[callbackName] = callback;
    std::cout << "[AssetManager] Registered import callback: " << callbackName << std::endl;
}

bool AssetManager::InitializeLua()
{
#ifdef FRESH_LUA_AVAILABLE
    luaState_ = luaL_newstate();
    if (!luaState_) {
        return false;
    }

    luaL_openlibs(luaState_);
    std::cout << "[AssetManager] Lua initialized" << std::endl;
    return true;
#else
    // Lua not available - use stub implementation
    std::cout << "[AssetManager] Lua not available - using stub implementation" << std::endl;
    return true;
#endif
}

void AssetManager::CloseLua()
{
#ifdef FRESH_LUA_AVAILABLE
    if (luaState_) {
        lua_close(luaState_);
        luaState_ = nullptr;
        std::cout << "[AssetManager] Lua closed" << std::endl;
    }
#else
    // Lua not available - nothing to close
    std::cout << "[AssetManager] Lua stub - nothing to close" << std::endl;
#endif
}

void AssetManager::OnAssetImported(const std::string& path, const std::string& type)
{
    for (const auto& pair : importCallbacks_) {
        pair.second(path, type);
    }
}

std::string AssetManager::GetFileExtension(const std::string& path) const
{
    fs::path p(path);
    std::string ext = p.extension().string();
    // Convert to lowercase
    std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    return ext;
}

std::string AssetManager::GetFileName(const std::string& path) const
{
    fs::path p(path);
    return p.filename().string();
}

bool AssetManager::EnsureDirectoryExists(const std::string& path)
{
    try {
        if (!fs::exists(path)) {
            fs::create_directories(path);
            std::cout << "[AssetManager] Created directory: " << path << std::endl;
        }
        return true;
    } catch (const fs::filesystem_error& ex) {
        std::cerr << "[AssetManager] Error creating directory: " << ex.what() << std::endl;
        return false;
    }
}

} // namespace fresh
